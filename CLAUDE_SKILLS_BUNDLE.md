# Latitude — Windsurf Skills Bundle
(autogenerated)


---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-biome-authority\SKILL.md

---
name: latitude-biome-authority
description: >
  Authoritative list of all vanilla Minecraft biomes and the latitude bands
  they are allowed to generate in for the Latitude (Globe) mod. This skill
  forbids guessing, omission, or reassignment of biomes and serves as the
  single source of truth for biome inclusion and climate eligibility.

---
# Latitude Biome Authority — Vanilla Minecraft (Java 1.21.11)
_Generated: 2026-01-31_

## RULES (MANDATORY)
- Every vanilla biome listed here **must exist** in at least one valid generation path.
- Windsurf must **never invent, remove, or reassign** biomes outside this table.
- If a biome is missing in-world, the cause is **tag omission or logic error**, not intentional rarity.
- **Latitude bands are authoritative**; variants and overlays are secondary.
- **Rarity is a design knob**, not a probability guarantee.
- Caves, rivers, oceans, Nether, and End biomes are **not latitude-decided unless explicitly stated**.
- Mountain / peak biomes are **overlays** and may restrict placement but **must not override latitude truth**.

---

## Latitude Bands

* **Equator** — hottest + wettest  
* **Tropics** — hot + wet-ish  
* **Arid** — hot + dry  
* **Temperate** — mild  
* **Subpolar** — cold  
* **Polar** — coldest  

**Overlay: Mountain / Peaks**  
Only allowed when “mountainness” is true (height, slope, or climate params), regardless of latitude.

---

## Plains / general land

| Biome | Band(s) | Rarity | Notes |
| --- | --- | --- | --- |
| Plains | Temperate | Common | Core mid-latitude flatland. |
| Sunflower Plains | Temperate | Rare | Rare plains variant. |
| Savanna | Arid ↔ Tropics | Uncommon | Warm transition biome. |
| Savanna Plateau | Arid / Tropics | Uncommon | Highland warm biome. |
| Snowy Plains | Subpolar | Common | Main cold flatland. |
| Ice Spikes | Polar | Very rare | Cold extreme. |
| Mushroom Fields | Any (special) | Very rare | Special-case island biome; not latitude-driven. |

---

## Forests / woodlands

| Biome | Band(s) | Rarity | Notes |
| --- | --- | --- | --- |
| Forest | Temperate | Common | |
| Birch Forest | Temperate | Common | |
| Flower Forest | Temperate | Rare | Discovery biome. |
| Dark Forest | Temperate | Uncommon | Dense canopy. |
| Old Growth Birch Forest | Temperate | Rare | Large birch variant. |
| Taiga | Temperate-high → Subpolar-low | Common | Key transition biome. |
| Old Growth Pine Taiga | Temperate-high → Subpolar | Uncommon | |
| Old Growth Spruce Taiga | Subpolar | Uncommon | |
| Snowy Taiga | Subpolar | Uncommon | |
| Pale Garden | Temperate (rare) | Very rare | Dark-forest-adjacent oddity. |

---

## Jungle family (warm + wet)

| Biome | Band(s) | Rarity | Notes |
| --- | --- | --- | --- |
| Jungle | Equator / Tropics | Uncommon | Dense near equator. |
| Bamboo Jungle | Equator / Tropics | Rare | |
| Sparse Jungle | Tropics | Uncommon | Transition biome. |
| Mangrove Swamp | Equator / Tropics | Rare | Must not appear in cool bands. |

---

## Swamps / wetlands

| Biome | Band(s) | Rarity | Notes |
| --- | --- | --- | --- |
| Swamp | Tropics ↔ Temperate-low | Uncommon | Warm temperate transition. |
| Mangrove Swamp | Equator / Tropics | Rare | Warm-only swamp. |

---

## Sandy / dry / badlands

| Biome | Band(s) | Rarity | Notes |
| --- | --- | --- | --- |
| Desert | Arid | Uncommon | |
| Badlands | Arid | Rare | |
| Wooded Badlands | Arid | Rare | |
| Eroded Badlands | Arid | Very rare | Extreme terrain. |

---

## Mountains / highlands (overlay-only)

| Biome | Band(s) | Rarity | Notes |
| --- | --- | --- | --- |
| Meadow | Temperate (overlay) | Uncommon | |
| Grove | Temperate-high / Subpolar (overlay) | Uncommon | Must be explicitly preserved. |
| Cherry Grove | Temperate (overlay) | Rare | |
| Windswept Hills | Temperate (overlay) | Uncommon | |
| Windswept Forest | Temperate (overlay) | Uncommon | |
| Windswept Gravelly Hills | Temperate (overlay) | Rare | |
| Windswept Savanna | Arid / Tropics (overlay) | Uncommon | |
| Stony Peaks | Arid / Tropics / Temperate (overlay) | Rare | |
| Jagged Peaks | Subpolar / Polar (overlay) | Rare | |
| Frozen Peaks | Subpolar / Polar (overlay) | Rare | |
| Snowy Slopes | Subpolar / Polar (overlay) | Uncommon | |
| Stony Shore | Any (adjacency overlay) | Uncommon | Mountains touching ocean only. |

---

## Caves (not latitude-driven)

| Biome | Band(s) | Rarity | Notes |
| --- | --- | --- | --- |
| Lush Caves | Any | Uncommon | |
| Dripstone Caves | Any | Uncommon | |
| Deep Dark | Any | Rare | |

---

## Beaches / shores (adjacency-driven)

| Biome | Band(s) | Rarity | Notes |
| --- | --- | --- | --- |
| Beach | Equator / Tropics / Arid / Temperate | Common | |
| Snowy Beach | Subpolar / Polar | Uncommon | |
| Stony Shore | Any (overlay) | Uncommon | |

---

## Rivers (temperature-driven)

| Biome | Band(s) | Rarity | Notes |
| --- | --- | --- | --- |
| River | Equator / Tropics / Arid / Temperate | Common | |
| Frozen River | Subpolar / Polar | Uncommon | |

---

## Oceans (temperature-driven)

| Biome | Band(s) | Rarity | Notes |
| --- | --- | --- | --- |
| Warm Ocean | Equator / Tropics | Uncommon | |
| Lukewarm Ocean | Tropics / Temperate-low | Uncommon | |
| Ocean | Temperate | Common | |
| Cold Ocean | Subpolar | Uncommon | |
| Frozen Ocean | Polar | Uncommon | |
| Deep Lukewarm Ocean | Depth overlay | Uncommon | |
| Deep Ocean | Depth overlay | Uncommon | |
| Deep Cold Ocean | Depth overlay | Uncommon | |
| Deep Frozen Ocean | Depth overlay | Uncommon | |

---

## The Nether (not latitude-driven)

| Biome | Band(s) | Rarity |
| --- | --- | --- |
| Nether Wastes | N/A | Common |
| Crimson Forest | N/A | Common |
| Warped Forest | N/A | Common |
| Soul Sand Valley | N/A | Uncommon |
| Basalt Deltas | N/A | Uncommon |

---

## The End (not latitude-driven)

| Biome | Band(s) | Rarity |
| --- | --- | --- |
| The End | N/A | Special |
| End Highlands | N/A | Common |
| End Midlands | N/A | Common |
| End Barrens | N/A | Common |
| Small End Islands | N/A | Uncommon |
| The Void | N/A | Special |

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-biome-selection-contract\SKILL.md

---
name: latitude-biome-selection-contract
description: Defines the contract between vanilla “base” biomes and Latitude “out” biomes. Prevents incorrect assumptions about F3 biome, temperature/precip flags, and feature placement. Provides the required debugging interpretation for LAT_PICK logs.
---

# Latitude — Biome Selection Contract (Authoritative)

This skill prevents a common error:
> “F3 says biome = jungle, therefore cold/snow features cannot trigger.”

That is false when:
- vanilla selects a cold **base** biome, and
- Latitude overrides to a warm **out** biome, but
- some vanilla systems still consult base-biome temperature/precip rules during placement.

---

## Definitions
- **Base biome**: the vanilla biome prior to Latitude override. Logged as `base=...` in `[LAT_PICK]`.
- **Out biome**: the biome Latitude returns to worldgen. Logged as `out=...` and typically what F3 shows.
- **Wrapper illusion**: you can see `out` while generation decisions still reference `base`.

---

## Contract rules (must be respected)
1) Latitude may override biome output by latitude band (Z-based), but vanilla may still:
   - consult base biome temperature,
   - consult precipitation flags,
   - run features keyed off base-biome climate.
2) Therefore:
   - Seeing cold blocks/features in a warm F3 biome implies **base leakage** or **write-path placement**, not that F3 is “wrong”.
3) Fixes must be either:
   - ensure temperature/precip checks use out-biome (harder), OR
   - block the offending feature/write path in disallowed bands (preferred for robustness).

---

## How to interpret `[LAT_PICK]` logs
Given a log line like:
- `zone=EQUATOR base=minecraft:snowy_taiga out=minecraft:jungle` 

Interpretation:
- Vanilla asked for a biome and would have used `snowy_taiga`.
- Latitude returned `jungle`.
- Any system that still consults base-biome climate may try to place snow/ice even though out-biome is warm.

This is expected in the presence of base leakage and does not mean Latitude selection failed.

### Representative `[LAT_PICK]` template

```
[LAT_PICK]
x=<x> z=<z> absZ=<absZ> radius=<radius> t=<t>
zone=<EQUATOR|TROPICS|ARID|TEMPERATE|SUBPOLAR|POLAR>
base=<minecraft:...>
out=<minecraft:...>
beachOverride=<true|false>
rareOverride=<true|false>
mangroveDecision=<...> cont=<...> ero=<...> weird=<...>
```

How to read it:
- If `out` is warm but `base` is cold, vanilla temperature-driven features may still attempt cold placements unless guarded (e.g., FreezeTopLayer).
- That’s not a biome-table bug; it’s a base-leakage / write-path issue.

---

## Debugging obligations
When a “contradiction” occurs (warm biome but cold artifacts):
1) Capture coords + F3 out-biome.
2) Find nearby `[LAT_PICK]` entries:
   - confirm `zone` and compare `base` vs `out`.
3) Identify write path:
   - feature hook logs (e.g., `FreezeTopLayerFeature`)
   - ChunkRegion/ProtoChunk traps
4) Apply minimal fix (feature cancel / write-path rewrite).

Do not propose band-table changes based only on F3.

---

## Canonical example: warm-band snow
Observed:
- F3: `minecraft:jungle` 
- Snow blocks or powder snow appear at cave mouths.

Common cause:
- `[LAT_PICK] base=snowy_plains out=jungle` 
- Vanilla `FreezeTopLayerFeature` consults base biome climate → attempts snow.
- LatitudeSnowGuard blocks/cancels in warm bands.

---

## Forbidden assumptions
- “Out biome implies all placements consult out biome.”
- “If snow appears, Latitude chose the wrong biome.”
- “Fix by moving snowy biomes out of authority table.”
- “Fix by rewriting MaterialRules first.”

---

## Required assistant output when diagnosing biome contradictions
The assistant must provide:
- base vs out interpretation
- suspected offender (feature or write path)
- the minimum guard/cancel plan
- a proof plan (log/counter) gated behind a debug flag

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-bug-triage-playbook\SKILL.md

---
name: latitude-bug-triage-playbook
description: Fast triage checklist for Latitude bug reports. Turns vague “something is wrong” reports into a small set of buckets (band math, biome pick, surface rules, features, write path, UI lifecycle, rendering/shaders, release mismatch) with minimal proof steps and lowest-effort fixes first.
---

# Latitude — Bug Triage Playbook (Authoritative)

Use this skill whenever:
- a player reports a bug
- a regression appears after a change
- you feel “this is going to be another 14-hour thing”

Goal: classify the bug into a known bucket in under ~10 minutes.

---

## Step 0 — Required report bundle (ask for this first)
If any are missing, request them (do not guess):

1) MC version: (e.g., 1.21.11 / 1.21.1)
2) Latitude version (jar filename preferred)
3) Mod loader + key mods:
   - Fabric Loader version
   - Fabric API version
   - Sodium? Iris? (and versions)
4) World type:
   - New world or existing world?
   - Seed (if relevant)
   - World border preset / diameter
5) Repro steps:
   - exact coords and what to do
6) Evidence:
   - F3 screenshot (shows biome + coords)
   - last ~120 lines of `latest.log` around the event (or filtered tags)

Minimal “fast ask” script:
- “Send: jar filename, MC version, Sodium/Iris versions, F3 screenshot at the spot, and your coords.”

---

## Step 1 — Identify the bucket (choose ONE)

### Bucket A — Release / version mismatch
Symptoms:
- jar name doesn’t match release notes
- behavior doesn’t match expected fix
- “I updated but nothing changed”

Checks:
- verify jar filename
- verify `mod_version` / tag used
- verify branch for the target

Skill to invoke:
- `latitude-release-discipline` 

---

### Bucket B — Zone math / band gating wrong
Symptoms:
- equator/poles feel shifted
- bands appear at wrong Z distances
- warm/cold classification wrong everywhere

Checks:
- compute `radius = worldBorderSize/2` 
- compute `t = abs(z)/radius` 
- confirm zone selection method is used everywhere

Skill to invoke:
- `latitude-zone-math-authority` 

---

### Bucket C — Biome eligibility / missing biome
Symptoms:
- biome never appears
- band has wrong biome family distribution
- “X biome is gone”

Checks:
- consult biome authority table
- confirm tags/logic includes biome
- treat as omission/logic bug, not rarity

Skill to invoke:
- `latitude-biome-authority` 

---

### Bucket D — “F3 says warm biome but cold blocks/features appear”
Symptoms:
- snow/powder snow/ice in jungle/desert
- “biome is correct but blocks are wrong”

Checks:
- locate `[LAT_PICK] base=... out=... zone=...` near the coords
- if base is cold while out is warm, suspect feature climate checks or late placement

Skill to invoke:
- `latitude-biome-selection-contract` 

---

### Bucket E — Wrong blocks placed (write-path problem)
Symptoms:
- “impossible block appears” (snow in tropics, ice in desert, etc.)
- tends to occur near cave mouths, ridges, or after features run

Checks:
- determine write path with one-shot log/counter:
  - Feature cancel logs (e.g., FreezeTopLayer)
  - ChunkRegion/ProtoChunk rewrite counters
- trap at choke point

Skill to invoke:
- `latitude-write-path-guards` 
- also: `latitude-debug-instrumentation-rules` for safe logging

---

### Bucket F — UI/HUD regression
Symptoms:
- a screen opens unexpectedly after joining world
- overlays render over menus/inventory
- controls/keys trigger at wrong times

Checks:
- confirm opening trigger (join tick vs keybind vs debug flag)
- enforce “no auto-open in-world”

Skill to invoke:
- `latitude-ui-and-hud-lifecycle` 

---

### Bucket G — Rendering / shaders / Sodium issues
Symptoms:
- fog/wall invisible with shaders
- flicker
- works vanilla but not with Sodium/Iris

Checks:
- confirm render callback is firing (single-shot ping)
- switch to minimal debug lines behind a toggle
- verify RenderLayer choice and entry-based vertex emission

Skill to invoke:
- `latitude-rendering-compat-rules` 

---

## Step 2 — Minimal proof strategy (avoid “new world fatigue”)

### Prefer deleting a region over making a new world
If the bug is worldgen-related and localized:
- delete only the affected region file to force regen:
  - `run/saves/<world>/region/r.<x>.<z>.mca` 

Proof steps:
1) Stand near the bad area.
2) Note coords.
3) Delete region file covering the coords.
4) Reload world to regen chunks.

If the bug is global/systemic (zone math, selection), then a fresh world may still be necessary.

---

## Step 3 — Fix policy (smallest effective fix)
- If write-path confirmed: fix at choke point (feature cancel → ChunkRegion → ProtoChunk)
- If selection wrong everywhere: fix zone math authority helper
- If missing biome: fix tag/eligibility logic, never delete the biome
- If UI: gate behind keybind/debug flag; default OFF
- If rendering: avoid GL state; use shader-safe layer/emission patterns

---

## Step 4 — Required exit criteria
Before closing a bug:
- one proof screenshot (or log line) showing “before vs after”
- debug toggles remain OFF by default
- one focused commit with clear message
- tag/savepoint if it touched worldgen or rendering

---

## Required assistant output format
For any bug report, assistant must output:

1) Bucket chosen (A–G)
2) Missing info request (if any)
3) Single next command / step
4) Minimal proof plan (no new world unless necessary)
5) Minimal fix plan (1–3 files)
6) Rollback plan

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-compat-backport-playbook\SKILL.md

---
name: latitude-compat-backport-playbook
description: Step-by-step playbook for backporting Latitude changes across MC 1.21.x targets (e.g., 1.21.11 -> 1.21.1). Enforces one-variable-at-a-time, cherry-pick discipline, minimal tests, version/tag correctness, and prevents branch/build confusion.
---

# Latitude — Compat Backport Playbook (Authoritative)

This skill is used whenever porting fixes between Minecraft versions (1.21.x), especially:
- main target: **1.21.11** (`main`)
- compat target: **1.21.1** (`compat/1.21.1`)

Goal: make backports boring and safe.

**Default mode: STRICT** — behavior must match across targets.
- Allowed exceptions only when vanilla signatures/behavior truly diverge between MC versions.
- Any exception must be documented in the commit/PR as: `Pragmatic exception: <why>` including the exact method signature difference.

---

## Golden rules
1) **One variable at a time**: one fix, one commit, one test.
2) Prefer **cherry-pick** of known-good commits over manual reimplementation.
3) Do not mix backport fixes with unrelated refactors.
4) Always confirm:
   - branch
   - mod_version
   - jar name
   - tags
5) If a change touches worldgen, require at least one runtime proof.

---

## Prep checklist (must pass)
On source branch (e.g., `main`):
- fix is committed and tested
- commit(s) are small and focused
- optional debug is gated and OFF by default

On target branch (e.g., `compat/1.21.1`):
- baseline builds cleanly before backport
- working tree is clean (or stash)

---

## Backport procedure (mandatory order)

### Step 1 — Baseline build on target branch
```powershell
git checkout compat/1.21.1
git pull
$env:GRADLE_USER_HOME = "$PWD\.gradle-user-home"
.\gradlew clean build --no-daemon
```

If baseline fails, STOP and fix baseline first.

---

### Step 2 — Identify minimal commits to port

Preferred: port only commits that touch:

* the specific mixin/feature/fix
* required config entries (mixins.json)
* required debug gating

Avoid porting:

* docs
* extracted sources
* tooling folders
* large unrelated refactors

Gather commit list using:

* `git log --oneline <sourceBranch> -- <filePath>` 
* `git show <hash> --name-only` 

---

### Step 3 — Cherry-pick onto target

From target branch:

```powershell
git cherry-pick <hash1> <hash2> ...
```

If conflicts:

* resolve by matching target MC signatures (method params/owners)
* do not change fix behavior while resolving compile errors
* keep edits minimal and localized

---

### Step 4 — Build on target

```powershell
$env:GRADLE_USER_HOME = "$PWD\.gradle-user-home"
.\gradlew clean build --no-daemon
```

If build fails:

* paste first ~60 lines of error
* adjust only signatures/descriptors until it compiles

---

### Step 5 — Minimal runtime proof (no “new world fatigue”)

Require exactly one proof run:

* start client
* generate a small area near a known test coordinate (or equator zone)
* confirm the fix triggers (via visual result or gated logs/counters)

If old chunks contain the old bug:

* delete only the relevant region file (`r.<x>.<z>.mca`) to regen

---

### Step 6 — Version + tag correctness (do NOT skip)

On the target branch, ensure `gradle.properties`:

* `mod_version=<release>+<mcVersion>` 

Then:

* build jars again
* confirm jar names match `mod_version` 

Tag must point to the commit that produces that jar:

```powershell
git tag -f v<mod_version>
git push origin -f v<mod_version>
```

---

## Common failure patterns (and required fixes)

### A) “I can’t checkout branch: gradle.properties would be overwritten”

Fix:

* `git stash push -m "temp: gradle.properties bump"` 
* checkout
* build
* later `git stash pop` on the original branch

### B) “I built but jar name is wrong”

Cause:

* target branch still has old `mod_version` 
  Fix:
* update `gradle.properties` on THAT branch
* commit
* rebuild

### C) “Incompatible mods found” during dev run

Cause:

* leftover jars in `run/mods` from a different MC target
  Fix:
* clear `run/mods/*` and `run/.fabric/processedMods/*` 

### D) Mixins apply failures on older target

Fix:

* remove non-essential mixin (especially precipitation hooks) if it fails apply
* keep the core guard/fix mixins
* re-run, then optionally reintroduce later

---

## Required assistant output format

When asked to backport:

1. Source branch + target branch
2. Commit list to cherry-pick (with reasons)
3. Exact commands (PowerShell)
4. Expected success outputs
5. Minimal runtime proof steps
6. Version/tag actions
7. Rollback strategy

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-debug-instrumentation-rules\SKILL.md

---
name: latitude-debug-instrumentation-rules
description: Rules for adding debug logs, counters, overlays, and sanity pings in Latitude. Enforces gated, minimal, removable instrumentation and forbids permanent spam in hot paths.
---

# Latitude — Debug Instrumentation Rules (Authoritative)

This skill is used whenever the assistant proposes:
- adding logs
- adding HUD/actionbar debug overlays
- adding counters
- adding “sanity ping” mixins
- adding temporary assertions/stack traces
- adding profiling toggles

Goal: make debugging **fast**, **low-noise**, and **safe to ship**.

---

## Non-negotiable rules
1) **All instrumentation is gated** behind a toggle (system property or in-mod debug flag).
2) Default for any debug toggle is **OFF**.
3) Never spam in hot paths (per-block/per-vertex/per-tick) without throttling.
4) Any debug change must be removable in one commit.
5) Every debug print must answer exactly **one question**.

## Debug flag naming standard (locked)

All debug instrumentation must follow this scheme:

- **Prefix:** `-Dlatitude.` 
- **Format:** `debug<FeatureName>` (camelCase)
- **Type:** boolean flags only (`true` enables)
- **Default:** OFF when not provided

Examples (canonical):
- `-Dlatitude.debugSnowGuard` 
- `-Dlatitude.debugWarmSnowTrap` 
- `-Dlatitude.debugOpenSpawnPicker` 
- `-Dlatitude.debugLatPick` 
- `-Dlatitude.debugRenderEwWall` 

Any new debug flag must conform to this naming scheme.

---

## Approved gating mechanisms (choose one)
Preferred: JVM system properties (dev-only)
- `-Dlatitude.debugSnowGuard=true` 
- `-Dlatitude.debugWarmSnowTrap=true` 
- `-Dlatitude.debugLatPick=true` 
- `-Dlatitude.debugRenderEwWall=true` 

Alternative: in-mod config keybind / config file (only if it already exists)

---

## Logging rules
### Throttle requirements
If a log is in a frequent path:
- print at most **once per N events** (e.g., once per 60 ticks or once per 256 calls)
- or “print only on first occurrence”
- or “print only when a match happens” (e.g., only when a snow block is seen)

### Content requirements
Logs must include:
- short tag in brackets: `[SNOWBLOCK_GUARD]`, `[FREEZE_GUARD]`, `[LAT_PICK]` 
- coords and/or chunk origin when relevant
- band/zone result when it is a latitude-related bug

Never log:
- full objects with huge toString output
- entire registry dumps
- per-biome spam across many chunks unless explicitly requested

---

## Counter/overlay rules (preferred over spam logs)
If the question is “is the hook firing?”:
- Use counters:
  - calls / matches / rewrites
- Show them via actionbar or HUD overlay
- Gate behind `-Dlatitude.debugWarmSnowTrap=true` 

Overlay update cadence:
- no more than once per 40 ticks (~2s) unless explicitly needed.

---

## Sanity ping rules
A sanity ping is allowed only when:
- a mixin is suspected not to apply
- a crash happens during early init
- environment mismatch is likely

Rules:
- print once, then stay silent
- must include the mixin name and target class
- must be removed or gated before release

---

## Stack trace / crash-once (nuclear) rules
Allowed only when:
- write path is unknown and must be identified
- symptom is rare and hard to reproduce

Rules:
- trigger only on the first match
- include an explicit comment: “REMOVE AFTER TRACE”
- must be behind a system property OR removed immediately after capture

---

## “Release safety” checklist (must pass before tagging)
Before creating a release tag:
- debug flags default OFF
- no ungated WARN spam in worldgen/render loops
- overlays disabled unless debug flag set
- `.gitignore` prevents debug-only artifacts from creeping into commits

---

## Expected assistant output
When proposing instrumentation, the assistant must output:
1) The exact question the instrumentation answers
2) The minimal hook point
3) The toggle name
4) The throttle strategy
5) The exact file(s) to edit
6) The removal plan (revert commit or flip flag)

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-generation-order-rules\SKILL.md

---
name: latitude-generation-order-rules
description: Canonical rules for how Latitude decides biomes and applies them across generation stages. Prevents the model from inventing steps, reordering pipeline stages, or “fixing” bugs by changing generation order.
---

# Latitude — Generation Order Rules (Authoritative)

This skill defines the **only allowed** high-level order of operations for Latitude worldgen and related runtime guards.
It exists to prevent the assistant from:
- Inventing new pipeline steps
- Reordering stages without evidence
- “Fixing” biome leaks by guessing different order
- Removing vanilla biomes or changing eligibility tables

If the assistant cannot prove a step from code, logs, or an attached authority table, it must say **UNKNOWN** and ask for the specific file / method signature.

---

## Primary authority files (must consult)
- **Vanilla biome latitude eligibility table** (single source of truth):
  - `.windsurf/skills/latitude-biome-authority/SKILL.md`
- **Biome bands reference (if present in repo docs / exports):**
  - `cc-latitude-comprehensive-2026-02-05.md` (project notes)
- **Any “LatitudeBiomes” / picker implementation**:
  - `src/main/java/com/example/globe/world/LatitudeBiomes.java` (or the current equivalent)

> Rule: If there is any conflict between a guess and an authority file, the authority file wins.

---

## Non-negotiable invariants
1) **All vanilla biomes must still exist** somewhere unless the authority list explicitly excludes them.
2) **Latitude bands constrain selection**; variants/overlays are secondary and may only restrict, not invent.
3) “Fixes” must not rely on changing worldgen order unless:
   - a concrete call site is identified, and
   - a targeted change is made with minimal surface area.
4) If snow/cold artifacts appear in warm bands, the allowed fixes are **write-path guards** (ProtoChunk/ChunkRegion/Feature cancel) or **correct biome container propagation** — not “change band table.”

---

## Canonical generation pipeline (high level)
When reasoning about how a block/biome appears, assume this order unless code proves otherwise:

### Stage A — Base / vanilla biome resolution
- Vanilla chooses a **base biome** (the “base=” shown in logs).
- Latitude may log this (e.g. `[LAT_PICK] base=...`).

### Stage B — Latitude selection and output biome override
- Latitude computes:
  - `radius = worldBorderSize / 2`
  - `t = abs(z)/radius`
  - `zone = band(t)`
- Latitude chooses an **out biome** (the biome returned to the generator).
- Latitude logs (example shape):
  - `[LAT_PICK] zone=EQUATOR base=snowy_taiga out=jungle ...`
- If the assistant proposes threshold changes, it must reference the exact helper/constants used.

### Stage C — Surface rules / material placement
- Surface rules (MaterialRules) place top blocks (grass/sand/snow_block, etc.) based on biome + noise.
- If “out biome” is warm but cold blocks appear, suspect that:
  - some placements still consult **base biome** temperature/precip flags, OR
  - placements happen through features after surface rules.

### Stage D — Feature placement / post-processing
- Features can place blocks using region/world access (e.g. `FreezeTopLayerFeature`).
- These may use biome temperature flags and can be triggered even when out biome is warm if base biome data leaks.

### Stage E — Runtime & write-path guards (Latitude protections)
Allowed guard layers (in order of preference for robustness):
1) **Feature-level cancel** for known offenders (e.g., cancel `FreezeTopLayerFeature` in warm bands)
2) **Write-path trap** at `ChunkRegion#setBlockState` during worldgen
3) **ProtoChunk#setBlockState` trap** for direct chunk writes
4) **Biome precipitation hooks** (only affect weather-driven snow layers, not worldgen blocks)

> Rule: If a block is still appearing, identify which write path is used by logging/stack trace; do not guess.

---

## Debugging protocol (mandatory)
When a worldgen artifact appears (snow/powder snow in warm bands, wrong biome, etc.):

1) **Confirm out biome** (F3) and capture coords (x,y,z).
2) Search logs for the decision record near that location:
   - `[LAT_PICK] ... base=... out=... zone=...`
3) Determine which system wrote the offending block:
   - Feature hook logs (e.g., `[FREEZE_GUARD]`)
   - Write-path logs (e.g., `[SNOWBLOCK_GUARD]`)
4) Only then propose the smallest fix:
   - cancel the feature, or
   - rewrite the blockstate at the write choke point, gated by warm band logic.

If any of these steps lack evidence, the assistant must request the relevant file/method signature.

---

## Allowed outputs the assistant may produce
- Exact “next step” commands (PowerShell) to locate call sites (`Select-String`, `git grep`, `jar tf`, etc.)
- Minimal patch plans: 1–3 files, 1–2 commits, with revert path
- Explicit “proof” instrumentation plans: single-shot logs, counters, or stack trace capture
- Release discipline steps: build, jar verify, tag placement, and Modrinth upload checklist

---

## Forbidden behaviors
- Inventing a “worldgen order” not supported by code/logs
- Reassigning biomes to bands to “fix” bugs
- Removing vanilla biomes because they’re “rare” or “problematic”
- Proposing broad refactors when a write-path guard would solve the symptom
- Shipping releases from branches polluted with extracted MC sources or tooling folders

---

## Reminder: one variable at a time
When making changes:
- One change per commit
- Test
- Tag savepoint if it touches generation
- Then proceed

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-player-facing-invariants\SKILL.md

---
name: latitude-player-facing-invariants
description: Authoritative “promise of Latitude” rules. Encodes the non-negotiable player-facing behaviors (climate continuity, band logic, no warm-band snow, intuitive exploration). Prevents technically-correct changes that break the mod’s feel.
---

# Latitude — Player-Facing Invariants (Authoritative)

This skill encodes the *promise* of Latitude to players. Any change that violates these invariants is a regression, even if it compiles.

---

## Core promise
Latitude turns Minecraft’s overworld into a planet-like climate experience:
- climate changes meaningfully with north/south travel
- bands feel continuous and intentional
- exploration “makes sense” without reading a wiki

---

## Non-negotiable invariants

### 1) Warm-band snow must be impossible
In warm bands (equator/tropical/subtropical as defined by the mod):
- No `snow_block` 
- No `snow` layers
- No `powder_snow` 
- No “frozen top layer” behavior

If any of these appear, it is a bug. Fix must use write-path guards or feature cancels, not biome reassignment.

### 2) Climate continuity over patchiness
- Bands should feel continuous across distance.
- “Islands” of totally wrong climate should be treated as bugs unless explicitly designed (and documented).

### 3) Distance must correlate with temperature
- Moving north/south changes temperature/biomes in a predictable direction.
- Any system that causes temperature to decorrelate from latitude needs strong justification.

### 4) All vanilla biomes still exist
- Unless explicitly excluded by the biome authority table, every vanilla biome must remain obtainable somewhere.
- Fixing a bug by effectively deleting a biome is forbidden.

### 5) The mod must be playable without debug knowledge
- Default gameplay should not require JVM flags.
- Debug features must not leak into normal play (no auto-open screens, no actionbar spam).

### 6) “Surprises” require communication
If the mod introduces hazards/effects (storms, polar danger, etc.):
- players must receive clear in-game feedback (HUD text, warning, particles, etc.)
- avoid silent punishment

---

## Required assistant behavior
When proposing changes, the assistant must state:
- which invariants are affected
- whether the change preserves them
- how to test the invariants quickly (minimal proof steps)

---

## Forbidden changes
- Adjusting biome bands to hide symptoms
- Shipping with debug toggles enabled by default
- Removing access to vanilla biomes because they are “problematic”
- Making climate feel random/patchy to “increase variety”

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-release-discipline\SKILL.md

---
name: latitude-release-discipline
description: Release guardrails for Latitude. Prevents tagging/building/uploading from the wrong branch, mismatched version strings, dirty working trees, or shipping dev/debug artifacts. Enforces one-step-at-a-time release checklist.
---

# Latitude — Release Discipline (Authoritative)

This skill exists to prevent release mistakes:
- building the wrong branch
- tagging the wrong commit
- uploading a jar whose version string doesn't match the release
- shipping with debug spam enabled
- releasing from a feature branch that contains extracted sources / tooling artifacts
- confusion between MC targets (1.21.11 vs 1.21.1)

If any checklist item fails, the assistant must say **STOP** and provide the single next command to fix it.

---

## Supported release targets (current)
- **Main target:** MC **1.21.11** (branch: `main`)
- **Compat target:** MC **1.21.1** (branch: `compat/1.21.1`)

> Never release 1.21.11 from a `feature/*` branch.
> Never assume `build/libs` contains the correct jar until after a clean build on the target branch.

---

## Preflight invariants (must be true)
1) Working tree clean (or only intended version bump changes)
2) Correct branch checked out for the target
3) `gradle.properties` contains the correct `mod_version` for that target
4) `./gradlew clean build` succeeds
5) The built jar filename matches the intended release string
6) Jar contents do not include extracted sources or tooling folders
7) Tag points at the commit that produced the jar

---

## One-step-at-a-time release protocol (mandatory)

### Step A — Confirm branch + cleanliness
Run:
- `git status` 
- `git branch --show-current` 

Rules:
- If `git status` shows local changes that would block checkout, **stash** with a message.
- If the branch is wrong, checkout the correct branch before doing anything else.

---

### Step B — Confirm version string (no guessing)
On the target branch:
- Inspect `gradle.properties` and confirm:
  - `mod_version=...` 

Required patterns:
- 1.21.11 build: `1.2.5+1.21.11` (example)
- 1.21.1 build: `1.2.5+1.21.1` (example)

If the jar name later shows a different version, the branch’s `mod_version` is wrong. Fix `gradle.properties`, commit, rebuild.

---

### Step C — Clean build with isolated Gradle home
Run from repo root:
```powershell
$env:GRADLE_USER_HOME = "$PWD\.gradle-user-home"
.\gradlew clean build --no-daemon
```

Then list jars:

```powershell
Get-ChildItem .\build\libs\*.jar | Select-Object Name, Length, LastWriteTime
```

Rule:

* If the expected jar is not present, do not proceed.

---

### Step D — Verify jar contents (must do once per release file)

Inspect the jar you will upload:

```powershell
jar tf .\build\libs\<YOUR_JAR_NAME>.jar | findstr /I "_mcsrc_extract .windsurf SKILL.md com/mojang blaze3d"
```

Pass criteria:

* No matches.

If there are matches:

* STOP. Rebuild from a clean branch and fix `.gitignore` or build config.

---

### Step E — Tag discipline (tags must match jar)

Preferred tags:

* `v<mod_version>` (example: `v1.2.5+1.21.11`)

Rules:

* Tag must be created/moved only **after** the jar is confirmed correct.
* If you must move a tag, use `-f` and force-push only that tag.

Commands:

```powershell
git tag -f v<mod_version>
git push origin -f v<mod_version>
```

---

### Step F — Upload discipline (Modrinth)

Rules:

* A single Modrinth release may contain multiple files.
* Each file must be assigned the correct game versions.
* Never upload a “fixed jar” without also ensuring the tag/branch state matches.

Minimum changelog bullets must include:

* the user-facing fix summary
* any important regression fix (UI, crashes)
* optional: debug flags are dev-only

---

## Branch hygiene rules (absolute)

* `main` is the only allowed release base for 1.21.11.
* `compat/1.21.1` is the only allowed release base for 1.21.1.
* Feature branches may contain experiments and must not own release tags.
* Extracted sources and tooling folders must never be part of a release commit:

  * `_mcsrc_extract/` 
  * `.windsurf/` 
  * other generated extraction folders

---

## If something is confusing, diagnose like this

1. List jars in `build/libs` 
2. Confirm current branch
3. Confirm `mod_version` in `gradle.properties` 
4. Rebuild
5. Re-list jars
6. Only then tag/upload

No other order is allowed.

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-rendering-compat-rules\SKILL.md

---
name: latitude-rendering-compat-rules
description: Rendering rules for Sodium/Iris compatibility in Latitude (E/W storm walls, fog, overlays). Forbids raw GL state, mandates entry-based vertex emission, approved RenderLayers, and shader-safe debugging patterns.
---

# Latitude — Rendering Compatibility Rules (Authoritative)

This skill applies to:
- E/W storm wall rendering
- custom fog overlays
- any world-space debug geometry
- any rendering that must work with Sodium + Iris

Goal: avoid “works vanilla, breaks with shaders” regressions.

---

## Non-negotiable rules
1) No direct GL state calls in mod render code:
- No `RenderSystem.*` state toggles
- No `GL11.*` 
- No manual blend/depth toggles

2) Always use modern vertex emission:
- `VertexConsumer` with `MatrixStack.Entry` 
- prefer built-in `RenderLayer`s / `RenderLayers` helpers
- never rely on “implicit” GL state being correct

3) Rendering must be safe under:
- Fabric renderer
- Sodium renderer
- Iris shader pipeline

---

## Approved rendering approaches
### A) World-space geometry (storm wall)
- Subscribe via the proper world render callback (not HUD)
- Use `WorldRenderContext` matrices/consumers
- Emit vertices using `vertex(entry, x,y,z).color(...).texture(...).light(...).normal(...);` 
- Keep geometry stable and avoid Z-fighting (slight inset if needed)

### B) Debug lines/quads
- Provide a compile-time or JVM-toggle to swap geometry:
  - line-only layer for shader visibility testing
  - quad layer for final

All debug visuals must be behind a toggle and off by default.

---

## Debug toggles (recommended)
- `-Dlatitude.debugRenderEwWall=true` 
- `-Dlatitude.debugEwWallLines=true` (lines vs quads)
- `-Dlatitude.debugFog=true` 

Default OFF.

---

## Performance / safety constraints
- Avoid per-frame allocations in hot render paths.
- Avoid extremely dense geometry; scale step size with distance if needed.
- Never spam actionbar logs; use one-shot logs or counters.

---

## Required assistant procedure for render bugs
When a render bug is reported (“not visible with shaders”, “flicker”, etc.), the assistant must:
1) Identify the current RenderLayer and emission style
2) Switch to a minimal debug layer (lines) behind a toggle
3) Confirm callback is firing (single-shot ping)
4) Reduce z-fighting (slight inset, depth tweaks via layer choice only)
5) Only then adjust final geometry/layer

---

## Forbidden behaviors
- “Just disable shaders” as a solution
- Adding render fixes by toggling GL state directly
- Shipping with debug render toggles enabled by default

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-repo-hygiene\SKILL.md

---
name: latitude-repo-hygiene
description: Repo hygiene rules for Latitude. Prevents generated/extracted artifacts from entering commits, release branches, tags, or jars. Provides the canonical ignore list and cleanup commands.
---

# Latitude — Repo Hygiene (Authoritative)

This skill prevents:
- accidental commits of extracted Minecraft sources
- accidental commits of tooling folders (Windsurf skills, caches)
- polluted feature branches being used for releases
- confusion around huge diffs unrelated to mod code

---

## Never-commit folders (absolute)
These must never be committed to any release branch (and should generally be ignored everywhere):

- `_mcsrc_extract/` 
- `run/` (worlds, logs, caches)
- `logs/` 
- `.gradle/` 
- `.gradle-user-home/` 
- `build/` 
- `out/` 
- `.idea/` 
- `.vscode/` 
- `.classpath` 
- `.project` 
- `.settings/` 
- `*.iml` 

Tooling:
- `.windsurf/` (skills, internal state) — **never ship inside jars**
- any `processedMods/` cache folder under `run/.fabric/` 

OS noise:
- `Thumbs.db` 
- `.DS_Store` 

If any of these appear in `git status`, STOP and fix before continuing.

---

## Release branch hygiene rules
- 1.21.11 releases must be tagged from `main` 
- 1.21.1 releases must be tagged from `compat/1.21.1` 
- Do not tag releases from `feature/*` branches, especially if they contain any forbidden folders.

---

## Required .gitignore policy
The repo must include ignore rules for every “never-commit folder” above.

If the assistant proposes adding a generated folder to the repo, it must justify why and confirm it is safe for release.

---

## Cleanup commands (PowerShell)
### Remove generated artifacts
```powershell
Remove-Item -Recurse -Force .\build -ErrorAction SilentlyContinue
Remove-Item -Recurse -Force .\.gradle -ErrorAction SilentlyContinue
Remove-Item -Recurse -Force .\.gradle-user-home -ErrorAction SilentlyContinue
Remove-Item -Recurse -Force .\run\.fabric\processedMods\* -ErrorAction SilentlyContinue
```

### If forbidden files were accidentally staged

```powershell
git restore --staged .
git restore .
```

### If forbidden files were committed (do not panic)

Preferred fix:

* revert the commit on the branch
* or rewrite history only if absolutely necessary and coordinated

---

## Jar safety check (must pass before upload)

Always check the jar you will upload:

```powershell
jar tf .\build\libs\<YOUR_JAR_NAME>.jar | findstr /I "_mcsrc_extract .windsurf SKILL.md com/mojang blaze3d"
```

Pass criteria:

* no matches.

---

## Required assistant output when repo pollution is detected

The assistant must:

1. identify the forbidden path(s)
2. provide the smallest safe cleanup action
3. ensure `.gitignore` prevents recurrence
4. ensure release tags are on clean branches

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-ui-and-hud-lifecycle\SKILL.md

---
name: latitude-ui-and-hud-lifecycle
description: Rules for when Latitude UI screens and HUD overlays may render or open. Prevents screens auto-opening in-world, enforces debug gating, and codifies “world creation only” flows.
---

# Latitude — UI & HUD Lifecycle (Authoritative)

This skill prevents UI regressions such as:
- spawn/band picker screens opening automatically after joining a world
- debug screens appearing without explicit user action
- HUD overlays rendering over menus/inventories unintentionally

---

## Screen-opening rules (absolute)
1) **No Latitude config screen may auto-open in-world** after joining/spawning.
2) Screens that configure worldgen (spawn band picker, presets, etc.) are **World Creation only**.
3) The only allowed in-world screen opens are:
   - explicit keybind action by the player, or
   - explicit debug flag enabled (dev-only), or
   - explicit command-driven open (if the mod provides commands).

Default must be **OFF** for any auto-open behavior.

---

## Approved gates for dev-only auto-open
If a developer convenience auto-open exists, it must be gated by a JVM property:
- `-Dlatitude.debugOpenSpawnPicker=true` (default false)

Rules:
- Must never be enabled by default.
- Must be clearly labeled “debug” in code comments.

---

## HUD overlay rendering rules
1) HUD overlays must not render when a GUI screen is open unless explicitly intended.
2) Default: if `MinecraftClient.currentScreen != null`, skip overlay rendering.
3) Exceptions must be explicit (e.g., a dedicated “HUD Studio” preview screen).

---

## Event lifecycle rules (client)
Do not open screens from:
- join world callbacks
- first tick hooks
- network handler init
- world load events

If a screen must be shown on world creation, it must be launched from:
- world creation UI integration points only

---

## Required assistant behavior
When asked to add a screen or overlay, the assistant must:
1) state the allowed opening triggers
2) specify the exact gate (keybind / debug property / world creation)
3) confirm “default OFF” for any auto-open
4) include a rollback plan

---

## Forbidden behaviors
- “Open this screen on join for convenience” unless gated behind a debug flag
- Rendering overlays over inventory/menus by default
- Shipping releases with debug auto-open enabled

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-write-path-guards\SKILL.md

---
name: latitude-write-path-guards
description: Canonical debugging + fix strategy for “wrong blocks in the wrong place” bugs. Forces evidence-first identification of the write path and mandates minimal, choke-point fixes (feature cancel / ChunkRegion / ProtoChunk). Forbids guessing via biome reassignment or pipeline invention.
---

# Latitude — Write-Path Guards (Authoritative)

This skill is used when:
- a block appears where it should be impossible (snow/powder snow in warm bands, ice in tropics, etc.)
- a “biome says X but blocks say Y” contradiction occurs
- a symptom persists despite precipitation/surface-rule changes

**Core rule:** Do not guess the cause. Identify the **write path** that placed the block, then block/rewrite it at the narrowest safe choke point.

---

## Definitions
- **Base biome:** vanilla biome selection prior to Latitude override (often logged as `base=`).
- **Out biome:** Latitude-selected biome returned to generation (often logged as `out=` / what F3 shows).
- **Write path:** the actual code path that calls `setBlockState` to place the offending block.

---

## Mandatory protocol (evidence-first)

### Step 1 — Capture the symptom precisely
Record:
- offending block(s) (e.g., `powder_snow`, `snow_block`)
- coords (x,y,z)
- F3 biome (out biome)
- zone/band if available

No fix proposals until these exist.

### Step 2 — Determine write path
Allowed methods (choose the least invasive that gives proof):

**A) Single-shot logs (preferred)**
- Add a guard that logs once when it sees the offending block type.
- Include:
  - block id
  - pos
  - band/zone result
  - (optional) chunk origin

**B) Stack trace capture (nuclear, one-time)**
- On first sighting, throw a controlled exception or log a stack trace.
- Use only once, then remove.

**C) Counter overlay**
- Maintain counters for:
  - calls
  - matches
  - rewrites
- Expose via debug HUD/actionbar behind a flag.

---

## Allowed choke points (use this order)

### 1) Feature-level cancel (best when a known offender exists)
Examples:
- `FreezeTopLayerFeature` (snow/ice)
- other single features when proven by stack trace

Rule:
- Cancel only in the disallowed bands/zones.
- Log once behind a debug flag.

### 2) `ChunkRegion#setBlockState` rewrite (best general guard)
- Catches many feature/placement writes during generation.
- Use `@ModifyVariable` or `@Redirect` carefully.
- Must be non-recursive.

### 3) `ProtoChunk#setBlockState` rewrite (good for direct chunk writes)
- Catches many worldgen surface placements.
- Often simpler than MaterialRules interception.

### 4) Biome precipitation hooks (last resort, limited scope)
- Only affects weather-driven snow layers / precipitation checks.
- Does not stop worldgen-placed `snow_block` or `powder_snow`.

---

## Band/zone gating rules (no hardcoding)
Warm-band detection must:
- derive radius from world border:
  - `radius = world.getWorldBorder().getSize() * 0.5` 
- compute:
  - `t = abs(z) / radius` 
- determine zone using the same helper/constants used by Latitude (do not duplicate thresholds unless unavoidable).

If a helper is not available, the assistant must:
- locate it in code first, or
- mark thresholds as UNKNOWN and ask for the file/constant.

---

## Canonical rewrite policy (snow family)
When in warm bands (equator/tropics/subtropics as defined by Latitude):

- `POWDER_SNOW` -> `AIR` 
- `SNOW` (layer) -> `AIR` 
- `SNOW_BLOCK` -> `DIRT` above sea level, else `STONE` 

All logging must be behind `-Dlatitude.debugSnowGuard=true` (or equivalent).

---

## Required safety constraints
- Guard must be **non-recursive** (do not call the same setBlockState path in a way that re-triggers).
- Guard must be band-gated (never global nukes unless explicitly set as a one-run diagnostic).
- Debug output must be gated and off by default for release.
- Fix must not change biome eligibility tables to hide the symptom.

---

## Forbidden fixes
- “Just move snowy biomes out of warm bands” (unless authority table explicitly says so)
- Reordering worldgen stages without proof
- Intercepting deep MaterialRules nested types unless all choke points above are proven insufficient
- Shipping with debug spam enabled

---

## Output format expected from the assistant
When asked to fix a block-placement bug, the assistant must produce:

1) **Hypothesis list** (max 3) tied to evidence
2) **Chosen choke point** and why
3) **Exact file(s) + mixin target + method descriptor**
4) **One commit plan** + test step
5) **Rollback path** (revert commit / toggle flag)

---

# C:\Users\jscho\CascadeProjects\Latitude (Globe)\.windsurf\skills\latitude-zone-math-authority\SKILL.md

---
name: latitude-zone-math-authority
description: Canonical authority for Latitude band math (radius, t, thresholds, and helpers). Prevents hardcoding, duplicated thresholds, or inconsistent warm/cold checks across worldgen, guards, fog, hazards, HUD, and features.
---

# Latitude — Zone Math Authority (Authoritative)

This skill ensures every system in Latitude uses the **same** band math:
- biome picking
- warm/cold guards (snow/ice/etc.)
- E/W storm fog borders
- hazards and effects
- HUD displays

If different parts of the code use different math, the mod becomes inconsistent and bugs reappear.

---

## Primary invariant: derive radius from world border
**Never hardcode radius.**

Use:
- `radius = world.getWorldBorder().getSize() * 0.5` 

Notes:
- WorldBorder size is a diameter-like value; radius is half.
- All band logic must use the same radius for the same world.

---

## Canonical latitude coordinate
Latitude is based on Z (north/south):

- `absZ = Math.abs(pos.getZ())` 
- `t = absZ / radius` 

Where:
- `t` is normalized latitude from 0.0 (equator) to 1.0 (border/pole).

Rules:
- Clamp t if needed: `t = Math.min(1.0, Math.max(0.0, t))` 
- Do not use X for latitude bands.
- Any “zone label” shown to player must correspond to this same t.

---

## Single source of truth for thresholds
There must be exactly one implementation that maps `t -> zone/band`:
- `LatitudeMath` or equivalent helper

All other systems must call that helper, not re-implement thresholds.

Allowed call shapes (examples):
- `LatitudeMath.zoneFor(world, pos)` 
- `LatitudeMath.zoneForT(t)` 
- `LatitudeZones.fromT(t)` 

If the helper does not exist, the assistant must:
1) locate where thresholds currently live, and
2) refactor so thresholds live in one place, then
3) update all call sites to reference it.

---

## Band naming contract
Band names used across logs/HUD/guards must be consistent.
Example canonical set:
- EQUATOR
- TROPICAL
- SUBTROPICAL
- TEMPERATE
- SUBPOLAR
- POLAR

If the project uses different names, mirror the project’s names exactly.

---

## Warm band / cold band predicates (required helpers)
Add and use helpers (names optional, behavior mandatory):

- `isWarmBand(zone)` returns true for bands that must never produce snow family blocks.
- `isColdBand(zone)` returns true for snow/ice-permitted bands.

Do not duplicate “warm band = t < X” logic in random places.

---

## Sea level authority
Avoid hardcoding y=63 unless intentionally matching vanilla sea level.

Preferred:
- `seaLevel = world.getSeaLevel()` (if available at the call site)

If not available, use a single project constant and document it.

---

## Debug output format requirements (when band math is involved)
If logging band math decisions, include:
- x, z, absZ
- radius
- t
- zone result

Example:
- `x=1514 z=-120 absZ=120 radius=10000 t=0.012 zone=EQUATOR` 

All such logs must be gated behind a debug flag.

---

## Forbidden behaviors
- Hardcoding radius (e.g., `radius=10000`) except in tests/tools
- Copying threshold numbers into multiple files
- Mixing X and Z for latitude decisions
- Using different t formulas for different features
- “Fixing” bugs by adjusting thresholds without referencing the authority helper

---

## Required assistant output when math is questioned
When asked “why is zone X here?” or “why is guard firing?” the assistant must:
1) show the formula used
2) show the radius source
3) show t computation
4) point to the helper/constant location in code
5) propose changes only in that single authority location
